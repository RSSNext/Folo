import { describe, expect, it } from "vitest"

// We'll test the internal logic by creating a simplified version
// since the actual generateRouteFileContent is internal to the plugin
describe("Code Generation", () => {
  it("should generate correct imports for sync files", () => {
    const syncImports = new Set(["./pages/critical.sync.tsx"])
    const syncImportMap = new Map([["./pages/critical.sync.tsx", "SyncComponent0"]])
    const fileToImportMap: Record<string, string> = {
      "./pages/critical.sync.tsx": "./pages/critical.sync",
    }

    const imports: string[] = []
    syncImports.forEach((key) => {
      const importPath = fileToImportMap[key]
      const syncImportName = syncImportMap.get(key)
      if (importPath && syncImportName) {
        imports.push(`import * as ${syncImportName} from "${importPath}"`)
      }
    })

    expect(imports).toEqual(['import * as SyncComponent0 from "./pages/critical.sync"'])
  })

  it("should generate correct imports for async files", () => {
    const lazyImports = new Set(["./pages/normal.tsx"])
    const lazyImportMap = new Map([["./pages/normal.tsx", "lazy0"]])
    const fileToImportMap: Record<string, string> = {
      "./pages/normal.tsx": "./pages/normal",
    }

    const imports: string[] = []
    lazyImports.forEach((key) => {
      const importPath = fileToImportMap[key]
      const lazyFuncName = lazyImportMap.get(key)
      if (importPath && lazyFuncName) {
        imports.push(`const ${lazyFuncName} = () => import("${importPath}")`)
      }
    })

    expect(imports).toEqual(['const lazy0 = () => import("./pages/normal")'])
  })

  it("should handle route object transformation", () => {
    const route = {
      path: "test",
      Component: "__SYNC_SyncComponent0.Component__",
      loader: "__SYNC_SyncComponent0.loader__",
    }

    const routesString = JSON.stringify([route], null, 2)
      .replaceAll(/"__SYNC_([^.]+)\.Component__"/g, '"$1.Component"')
      .replaceAll(/"__SYNC_([^.]+)\.loader__"/g, '"$1.loader"')

    expect(routesString).toContain('"Component": "SyncComponent0.Component"')
    expect(routesString).toContain('"loader": "SyncComponent0.loader"')
  })

  it("should remove undefined loader properties", () => {
    const routeString = `{
  "path": "test",
  "Component": "SyncComponent0.Component",
  "loader": undefined
}`

    const cleaned = routeString.replaceAll(/,?\s*"loader":\s*undefined/g, "")

    expect(cleaned).toContain('"Component": "SyncComponent0.Component"')
    expect(cleaned).not.toContain('"loader"')
  })

  it("should generate complete route file content", () => {
    const syncImports = ['import * as SyncComponent0 from "./pages/critical.sync"']
    const lazyImports = ['const lazy0 = () => import("./pages/normal")']
    const routes = [
      {
        path: "critical",
        Component: "SyncComponent0.Component",
        loader: "SyncComponent0.loader",
      },
      {
        path: "normal",
        lazy: "lazy0",
      },
    ]

    const content = `// This file is auto-generated by vite-plugin-route-builder
// Do not edit manually
/* eslint-disable */
// @ts-nocheck

import type { RouteObject } from "react-router"

// Imports for page components
${[...syncImports, ...lazyImports].join("\n")}

// Generated route configuration
export const routes: RouteObject[] = ${JSON.stringify(routes, null, 2)}

export default routes
`

    expect(content).toContain("import * as SyncComponent0")
    expect(content).toContain("const lazy0 = () => import")
    expect(content).toContain('"Component": "SyncComponent0.Component"')
    expect(content).toContain('"loader": "SyncComponent0.loader"')
    expect(content).toContain('"lazy": "lazy0"')
    expect(content).toContain("export const routes: RouteObject[]")
  })

  it("should handle file extension replacement correctly", () => {
    const testCases = [
      {
        input: "./pages/test.sync.tsx",
        expected: "./pages/test.sync",
      },
      {
        input: "./pages/test.tsx",
        expected: "./pages/test",
      },
    ]

    testCases.forEach(({ input, expected }) => {
      let result: string
      if (input.endsWith(".sync.tsx")) {
        result = input.replace(/\.tsx$/, "")
      } else {
        result = input.replace(/\.tsx$/, "")
      }

      expect(result).toBe(expected)
    })
  })
})
